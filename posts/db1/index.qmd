---
title: Database 1
author: Kirill Voronin
date: 2023-08-08
bibliography: references.bib
---

## Disclaimer

The approach and the software described in this paper is mainly based on our experience of biostatistics dept. of Fed. Research Center. See [@cdm] to get more context and see how our approach fits in general clinical data management.

<!-- In another circumstances and with another resources available at hand you might have better fit with another approach. Though we try to generalize it and make useful outside of our organization as much as possible. -->

## Introduction

## User (Who?)

Narrow target user.

Our user is Helgi, Antony and maybe Pablo.

## Problem (What?)

## When?

## Where?

Not pharma.

## Approach

### DB is to DBA, we gonna work with it.

We don’t force a DBA into a specific data structure, but give em flexibility. A DBA has better knowledge of tradeoffs, which make the whole database, data management and querying simpler. Also we don’t need to make these groundbreaking decisions ourselves and chain us with them.

Of course it doesn’t come for free, but with a cost of requiring a database developer to write and work with queries and write some code to glue provided components with a custom database. But it is a cost we **would like** to pay, partly because our engineers have a great experience working with a code.

### Integrated environment

R and RStudio example, though remark why we have choosen dev containers (road diverge sign).

### HTML

HTML because we just want to display it, though remark why we have choosen JSX. (road diverge sign).

No client state (managed by database developer), only by software developer, because threading and managing state is hard. [2]

### Functional programming

We prefer functional programming because of it’s composeable and declarative style [@rmonads]. Compare first and second [@rmonads] snippets.

Missing side-effects and explicit data handling makes functions easier to understand and test, they are simple.

Our end goal is highly configurable application for any kind of database. Obviously it requires not plain text configuration but programming, yet that’s not we would like to dive in deep. Functions are those simple building block which allow us to compose our applications. They are much simple than classes and OOP.

In JavaScript programmers mostly use Lodash or it’s counterpart lodash/fp or RamdaJS, which goes much further with functional programming [@thinking-in-ramda]. This raises a question on programming style we use.

### Code linearization, point-free programming and pipes

When we heavily rely on functions we usually end up with a lot of calls of small functions which return and pass each other themselves. Those calls frequently are heavily nested which makes them hard to ready. See [tc39/pipes] for examples.

To get readability back we have multiple techniques of code linearization. All of them are useful and not any one must become an absolute.

Lodash uses *method chaining*. It‘s very popular in JavaScript. D3 also uses it heavily, other popular libraries like jQuery and Zod does this too. As much as popular it is limited in extension.
For example, see next Knex code `knex().connection(con).select("*").from("table")`. What if we want to predefine conenction?

```js
const con;
const knexc = (...args) => knex(...args).connection(con);
knexc().select("*").from("tableA")
knexc().select("*").from("tableB") # nop, still tableA, because it's mutable QueryBuilder object :(
```

RamdaJS pushes functional programming to it’s extent with currying [@why-curry-helps] and functional composition to achieve what‘s called *point-free or tacit programming*. Though it feels alien in JS world [@does-curry-help] and hard for most programmers [@pointless], partially because of data-last arguments in function signatures, this is another technique in our toolbox.

In R we are accustomed to what is called pipe [@r4ds-pipes] or threading macro in Clojure. There is a proposal for *pipe* in JS [tc39/pipes] [tc39/pipes-206] which keeps data-first regular arguments.

Actually both of this techniques are sort of *partial function application*, which can be achieved in different ways [currying-in-js]. Notably:

- using arrow functions
- using partial
- using bind
- special syntax? probably not soon, as pipes

After all, we can just use *intermediate variables*. Though for small portions of code it is too wordy and makes things harder to read. Also, as we know naming is hard [@twohardthings]. On the other hand, giving something a name can increase readability. In general it’s better to avoid mutable variables.

Our goal is to make code easily [@simplemadeeasy] composeable and readable. All tools are good, though we tend to method chaining as it‘s common one and true functional composition with partial application and pipes, but not point-free style.

We suggest to conform to tidyverse code style for pipes when to use each technique [@r4ds-pipes].
 
### Static analysis.
  
Static typing for developers, type inference for users.  
  
It makes building software a lego game (is it something good? probably yes, in our case).  
  
Clojure.spec is another approach, which states tooling in its rationale paper, yet we don’t see it (namely static code analysis, because or users are particularly bad at writing and **executing** code), for example in clj-kondo wich is commonly used linter, though LISPs are perfect languages for tooling due to ease of parsing, see LighTable. (road diverge sign).  

## Borrowed

2.  [@riffle]

Backend first

> We think one promising pattern is a [local-first architecture](https://www.inkandswitch.com/local-first/) where all data is stored locally on the client, available to be freely edited at any time, and synchronized across clients whenever a network is available.

То же самое, только backend-first, потому что, нам нужна централизация и бэкграунд таски.

Database centric

> In this sense, our approach is reminiscent of tools like [Datascript](https://github.com/tonsky/datascript) and [LINQ](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/) which expose a query interface over in-memory data structures.

Вот это круто, но не уверен, что хорошая идея в базе хранить стейт пользователей.

> См. первый запрос

Они ставят лейблы как Олег и Миша, через JOIN.

> Structured queries make it easier to understand an app
> The Riffle model produces a highly structured app. Each component contains:
> * local relational **state**
> * reactive **queries** that transform data
> * a **view template** for rendering DOM nodes and registering event handlers

> In some sense, the view template is also a “query”: it’s a pure function of the data returned by the queries, and its expressed in a declarative, rather than imperative style! So, we can view the queries and template together as a large, tree-structured view of the data—the sources are the base tables, the sinks are the DOM templates, and the two are connected by a tree of queries. All dependencies are known by the system at runtime.
> The pervasive use of relational queries seems to be a better fit for debugging data-intensive programs, although we feel that we’ve only scratched the surface of the problem.
> Another challenge was fitting compound UI state like nested objects or sequences into the relational model. For now, we’ve addressed this challenge by serializing this kind of state into a single scalar value within the relational database. However, this approach feels haphazard, and it seems important to find more ergonomic relational patterns for storing common kinds of UI state.

Это не решается, если только само дерево например в JSON не сохранить.

> SQL is a mediocre language for UI development

Да, согласен по каждому пункту.

> While we tried to stick to well-known technologies like SQL in our prototype, we are excited about the potential of newer relational languages like [Imp](https://github.com/jamii/imp/tree/v1) and Datalog.

А у нас, как пользователей R, хороший экспириенс относительно ФП языка для этого.

# Dataflow

https://github.com/hyperfiddle/electric
> Electric Clojure implements a form of arrowized continuous time dataflow programming with extensions for network-transparent function composition.
> references

# Framework

Biff is a good example.
[Growing a framework](https://jacobobryant.com/p/post-2019-grow/)
[Growing a language]()

# IoC

[Martin Fowler IoC](https://martinfowler.com/bliki/InversionOfControl.html)
> Inversion of Control is a key part of what makes a framework different to a library.
> A framework embodies some abstract design, with more behavior built in. In order to use it you need to insert your behavior into various places in the framework either by subclassing or by plugging in your own classes.

But important:
> There is some confusion these days over the meaning of inversion of control due to the rise of IoC containers; some people confuse the general principle here with the specific styles of inversion of control (such as dependency injection) that these containers use.